<patch-1.0 appVersion="1.0.12">
   <comment type="patch/comment" x="14" y="14" text="simply assign cc1..119 to any control (right click, Midi CC)"/>
   <comment type="patch/comment" x="14" y="42" text="very stable when using objects with dials"/>
   <comment type="patch/comment" x="350" y="42" text="certain objects have params incompletely registered by java editor (e.g. sel/sel fb 16"/>
   <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_1" x="14" y="56">
      <params>
         <frac32.u.map name="value" MidiCC="1" value="27.5"/>
      </params>
      <attribs/>
   </obj>
   <patchobj type="patch/object" uuid="33947225-fec7-447f-a949-c433ac531457" name="sel_2" x="126" y="56">
      <params>
         <frac32.s.map name="v0" MidiCC="16" value="-42.0"/>
         <frac32.s.map name="v1" MidiCC="17" value="-17.0"/>
         <frac32.s.map name="v2" MidiCC="18" value="-48.0"/>
         <frac32.s.map name="v3" MidiCC="19" value="-48.0"/>
         <frac32.s.map name="v4" value="0.0"/>
         <frac32.s.map name="v5" value="0.0"/>
         <frac32.s.map name="v6" value="0.0"/>
         <frac32.s.map name="v7" value="0.0"/>
         <frac32.s.map name="v8" value="0.0"/>
         <frac32.s.map name="v9" value="0.0"/>
         <frac32.s.map name="v10" value="0.0"/>
         <frac32.s.map name="v11" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="33947225-fec7-447f-a949-c433ac531457">
         <sDescription>selectable constant bipolar</sDescription>
         <author>Simon Iten</author>
         <license>BSD</license>
         <inlets>
            <int32 name="s" description="select"/>
         </inlets>
         <outlets>
            <frac32.bipolar name="o"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="v0"/>
            <frac32.s.map name="v1"/>
            <frac32.s.map name="v2"/>
            <frac32.s.map name="v3"/>
            <frac32.s.map name="v4"/>
            <frac32.s.map name="v5"/>
            <frac32.s.map name="v6"/>
            <frac32.s.map name="v7"/>
            <frac32.s.map name="v8"/>
            <frac32.s.map name="v9"/>
            <frac32.s.map name="v10"/>
            <frac32.s.map name="v11"/>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[switch(inlet_s>0?inlet_s:0) {
      case 0: outlet_o= param_v0; break;
      case 1: outlet_o= param_v1; break;
      case 2: outlet_o= param_v2; break;
      case 3: outlet_o= param_v3; break;
      case 4: outlet_o= param_v4; break;
      case 5: outlet_o= param_v5; break;
      case 6: outlet_o= param_v6; break;
      case 7: outlet_o= param_v7; break;
      case 8: outlet_o= param_v8; break;
      case 9: outlet_o= param_v9; break;
      case 10: default: outlet_o= param_v10; break;
   }]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="33947225-fec7-447f-a949-c433ac531457" name="sel_3" x="210" y="56">
      <params>
         <frac32.s.map name="v0" MidiCC="28" value="-48.0"/>
         <frac32.s.map name="v1" MidiCC="29" value="-30.0"/>
         <frac32.s.map name="v2" MidiCC="30" value="-48.0"/>
         <frac32.s.map name="v3" MidiCC="31" value="-48.0"/>
         <frac32.s.map name="v4" value="0.0"/>
         <frac32.s.map name="v5" value="0.0"/>
         <frac32.s.map name="v6" value="0.0"/>
         <frac32.s.map name="v7" value="0.0"/>
         <frac32.s.map name="v8" value="0.0"/>
         <frac32.s.map name="v9" value="0.0"/>
         <frac32.s.map name="v10" value="0.0"/>
         <frac32.s.map name="v11" value="0.0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="33947225-fec7-447f-a949-c433ac531457">
         <sDescription>selectable constant bipolar</sDescription>
         <author>Simon Iten</author>
         <license>BSD</license>
         <inlets>
            <int32 name="s" description="select"/>
         </inlets>
         <outlets>
            <frac32.bipolar name="o"/>
         </outlets>
         <displays/>
         <params>
            <frac32.s.map name="v0"/>
            <frac32.s.map name="v1"/>
            <frac32.s.map name="v2"/>
            <frac32.s.map name="v3"/>
            <frac32.s.map name="v4"/>
            <frac32.s.map name="v5"/>
            <frac32.s.map name="v6"/>
            <frac32.s.map name="v7"/>
            <frac32.s.map name="v8"/>
            <frac32.s.map name="v9"/>
            <frac32.s.map name="v10"/>
            <frac32.s.map name="v11"/>
         </params>
         <attribs/>
         <includes/>
         <code.krate><![CDATA[switch(inlet_s>0?inlet_s:0) {
      case 0: outlet_o= param_v0; break;
      case 1: outlet_o= param_v1; break;
      case 2: outlet_o= param_v2; break;
      case 3: outlet_o= param_v3; break;
      case 4: outlet_o= param_v4; break;
      case 5: outlet_o= param_v5; break;
      case 6: outlet_o= param_v6; break;
      case 7: outlet_o= param_v7; break;
      case 8: outlet_o= param_v8; break;
      case 9: outlet_o= param_v9; break;
      case 10: default: outlet_o= param_v10; break;
   }]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="350" y="70" text="toggle and iradio types work but..."/>
   <comment type="patch/comment" x="602" y="70" text="workarounds exist but that&apos;s another story"/>
   <comment type="patch/comment" x="350" y="84" text="java editor naming is janky (panelLCD)"/>
   <comment type="patch/comment" x="602" y="84" text="can you help add support for these?"/>
   <comment type="patch/comment" x="350" y="98" text="and the [C&apos;] menu is not drawn"/>
   <obj type="sel/sel fb 16" uuid="f4aa3eb141915b6fc722e576dde344a226a022ac" name="sel_1" x="602" y="98">
      <params>
         <frac32.s.mapvsl name="b0" value="-1.0"/>
         <frac32.s.mapvsl name="b1" value="0.0"/>
         <frac32.s.mapvsl name="b2" value="0.0"/>
         <frac32.s.mapvsl name="b3" value="0.0"/>
         <frac32.s.mapvsl name="b4" value="0.0"/>
         <frac32.s.mapvsl name="b5" value="0.0"/>
         <frac32.s.mapvsl name="b6" value="0.0"/>
         <frac32.s.mapvsl name="b7" value="0.0"/>
         <frac32.s.mapvsl name="b8" value="0.0"/>
         <frac32.s.mapvsl name="b9" value="0.0"/>
         <frac32.s.mapvsl name="b10" value="0.0"/>
         <frac32.s.mapvsl name="b11" value="0.0"/>
         <frac32.s.mapvsl name="b12" value="0.0"/>
         <frac32.s.mapvsl name="b13" value="0.0"/>
         <frac32.s.mapvsl name="b14" value="0.0"/>
         <frac32.s.mapvsl name="b15" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="ctrl/toggle" uuid="42b8134fa729d54bfc8d62d6ef3fa99498c1de99" name="toggle_1" x="350" y="112">
      <params>
         <bool32.tgl name="b" MidiCC="20" value="0"/>
      </params>
      <attribs/>
   </obj>
   <obj type="env/ahd" uuid="2139369d6de2ba5ddf76e602d1d25df653ca9eed" name="ahd_1" x="14" y="154">
      <params>
         <frac32.s.map name="a" MidiCC="2" value="-15.0"/>
         <frac32.s.map name="d" value="0.0"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="420" y="154" text="assigned CC20"/>
   <obj type="phi/ctrl/i radio 6 h" uuid="81c4cf13a2d0e267b337a4663a711c2f96f7f9b7" name="i_2" x="350" y="168">
      <params>
         <int32.hradio name="value" MidiCC="21" value="5"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="462" y="210" text="cc21"/>
   <obj type="ctrl/i radio 4 v" uuid="b610704137c90b0e43464440b84bfb4fb7d2bb30" name="i_1" x="350" y="224">
      <params>
         <int32.vradio name="value" MidiCC="22" value="3"/>
      </params>
      <attribs/>
   </obj>
   <comment type="patch/comment" x="434" y="280" text="cc22"/>
   <comment type="patch/comment" x="350" y="336" text="subpatched parameters are functional"/>
   <comment type="patch/comment" x="672" y="336" text="manually invoke a status report"/>
   <patcher type="patch/patcher" uuid="985809f9-333a-4f66-9293-c4913a5f68b9" name="patcher_1" x="350" y="350">
      <params>
         <frac32.s.map name="dial_b" MidiCC="23" value="-48.0"/>
         <frac32.u.map name="dial_p" MidiCC="24" value="27.0"/>
      </params>
      <attribs/>
      <subpatch appVersion="1.0.12">
         <comment type="patch/comment" x="28" y="14" text="these have &quot;parameter on parent&quot; set in the java editor here"/>
         <comment type="patch/comment" x="28" y="28" text="and the topmost patcher dials are assigned in the java editor"/>
         <comment type="patch/comment" x="28" y="56" text="this causes PEx.pfunction = PropagateToSub"/>
         <comment type="patch/comment" x="28" y="70" text="and PEx.finalvalue = (int32_t)(&amp;(PExch[PARAM_INDEX_ETC]))"/>
         <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="dial_b" x="28" y="98">
            <params>
               <frac32.s.map name="value" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_p" x="126" y="98">
            <params>
               <frac32.u.map name="value" onParent="true" value="0.0"/>
            </params>
            <attribs/>
         </obj>
         <comment type="patch/comment" x="28" y="196" text="our [PanelAssign] object follows this pointer such that "/>
         <comment type="patch/comment" x="28" y="210" text="assignments are to subpatch parameters (not the parent)"/>
         <nets/>
         <settings>
            <subpatchmode>no</subpatchmode>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>0</x>
            <y>23</y>
            <width>464</width>
            <height>338</height>
         </windowPos>
      </subpatch>
   </patcher>
   <patcher type="patch/patcher" uuid="73349dbe-82e6-4058-9843-2bf3c6098152" name="patcher_2" x="504" y="350">
      <params>
         <frac32.u.map name="sub:dial_p" MidiCC="25" value="18.0"/>
         <frac32.s.map name="sub:dial_b" MidiCC="26" value="-18.0"/>
      </params>
      <attribs/>
      <subpatch appVersion="1.0.12">
         <comment type="patch/comment" x="14" y="28" text="sub-subpatches are somewhat functional with minor inconveniences"/>
         <comment type="patch/comment" x="14" y="42" text="such as naming appearing incorrectly in [panelLCD]"/>
         <patcher type="patch/patcher" uuid="b0931b0c-63b2-401f-88fd-2bf0521463e4" name="sub" x="14" y="70">
            <params>
               <frac32.u.map name="dial_p" onParent="true" value="0.0"/>
               <frac32.s.map name="dial_b" onParent="true" value="0.0"/>
            </params>
            <attribs/>
            <subpatch appVersion="1.0.12">
               <obj type="ctrl/dial p" uuid="cc5d2846c3d50e425f450c4b9851371b54f4d674" name="dial_p" x="14" y="42">
                  <params>
                     <frac32.u.map name="value" onParent="true" value="0.0"/>
                  </params>
                  <attribs/>
               </obj>
               <obj type="ctrl/dial b" uuid="862e7d7f29093cb1ce4aed72244d118ad4d46692" name="dial_b" x="98" y="42">
                  <params>
                     <frac32.s.map name="value" onParent="true" value="0.0"/>
                  </params>
                  <attribs/>
               </obj>
               <nets/>
               <settings>
                  <subpatchmode>no</subpatchmode>
               </settings>
               <notes><![CDATA[]]></notes>
               <windowPos>
                  <x>0</x>
                  <y>23</y>
                  <width>400</width>
                  <height>400</height>
               </windowPos>
            </subpatch>
         </patcher>
         <comment type="patch/comment" x="14" y="238" text="see patcher_1 for more info on how subpatched parameters behave"/>
         <comment type="patch/comment" x="14" y="252" text="can you help improve stability for these?"/>
         <nets/>
         <settings>
            <subpatchmode>no</subpatchmode>
         </settings>
         <notes><![CDATA[]]></notes>
         <windowPos>
            <x>0</x>
            <y>23</y>
            <width>400</width>
            <height>400</height>
         </windowPos>
      </subpatch>
   </patcher>
   <comment type="patch/comment" x="672" y="350" text="also by PGM127"/>
   <patchobj type="patch/object" uuid="b6cf2565-3afa-43b3-97aa-63bef828639f" name="state" x="672" y="364">
      <params>
         <bool32.mom name="send" value="0"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="b6cf2565-3afa-43b3-97aa-63bef828639f">
         <sDescription>tx pgm127 internally - causes [panelControl] to report state</sDescription>
         <helpPatch>midi_out.axh</helpPatch>
         <inlets/>
         <outlets/>
         <displays/>
         <params>
            <bool32.mom name="send"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[int ntrig;]]></code.declaration>
         <code.krate><![CDATA[if ((param_send>0) && !ntrig) {MidiSend2((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_PROGRAM_CHANGE + MIDICHANNEL, 127); ntrig=1;}
if (!(param_send>0)) ntrig=0;]]></code.krate>
      </object>
   </patchobj>
   <comment type="patch/comment" x="434" y="378" text="cc23"/>
   <comment type="patch/comment" x="602" y="378" text="cc25"/>
   <comment type="patch/comment" x="434" y="406" text="cc24"/>
   <comment type="patch/comment" x="602" y="406" text="cc26"/>
   <comment type="patch/comment" x="14" y="644" text="panel objects must be the LOWEST objects in the java patch editor"/>
   <comment type="patch/comment" x="14" y="658" text="- these interact with each other using hacky-kludgy-API stuff"/>
   <comment type="patch/comment" x="14" y="672" text="- so make sure they appear in order [LCD][Control][Midi][Assign]"/>
   <patchobj type="patch/object" uuid="aeda73fe-cee0-418f-b4b6-0cce5c671f53" name="panelLCD" x="14" y="686">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="aeda73fe-cee0-418f-b4b6-0cce5c671f53">
         <sDescription>configures I2C LCD screen using pins PB8=SCL PB9=SDA</sDescription>
         <author>zenpho</author>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[// ///////////////////////////////////////////////////////
// local copy of values discovered in companion 'panelAssign'
// array of label text - sixteen characters per label
// exactly NPEXCH labels, indexed as per patchMeta.pPExch
char labels[NPEXCH][16];

// ///////////////////////////////////////////////////////
// local copy of value stored in companion 'panelMidi'
// for which parameter is 'current' received or transmitted
// k-rate pulls currentPExIdx value from companion 'panelMidi'
// the LCD thread handles updating and checking previouPExIDx
int32_t currentPExIdx; // valid range 0 to NPEXCH
int32_t previouPExIdx; // track changes to currentPExIdx

// ///////////////////////////////////////////////////////
// pointer to array stored in companion 'panelAssign'
int8_t* ccAssignments = 0; //

// pointer to array stored in companion 'panelControl'
int8_t* ctrlIsHooked = 0; //

// pointer to array stored in companeion 'panelMidi'
int8_t* prevMidiValue = 0; //

// ///////////////////////////////////////////////////////
// local copy of values stored in companion 'panelControl'
// k-rate pulls values from companion 'panelControl' 
int8_t currentPage; // valid range 0 to 7
int8_t previousPage; // track changes to page
int8_t currControl; // 0 to 11, used by dispValCurrControl()

// ///////////////////////////////////////////////////////
// set up the thread for the i2c LCD screen comms
msg_t ThreadX2(){
  setup();
  while(!chThdShouldTerminate()){
     loop();
     chThdSleepMilliseconds(1);
  }
  chThdExit((msg_t)0);
}
static msg_t ThreadX(void *arg) {
  ((attr_parent *)arg)->ThreadX2();
}
WORKING_AREA(waThreadX, 1024);
Thread *Thd;

// ///////////////////////////////////////////////////////

// commands
#define LCD_CLEARDISPLAY 0x01
#define LCD_RETURNHOME 0x02
#define LCD_ENTRYMODESET 0x04
#define LCD_DISPLAYCONTROL 0x08
#define LCD_CURSORSHIFT 0x10
#define LCD_FUNCTIONSET 0x20
#define LCD_SETCGRAMADDR 0x40
#define LCD_SETDDRAMADDR 0x80

// flags for display entry mode
#define LCD_ENTRYRIGHT 0x00
#define LCD_ENTRYLEFT 0x02
#define LCD_ENTRYSHIFTINCREMENT 0x01
#define LCD_ENTRYSHIFTDECREMENT 0x00

// flags for display on/off control
#define LCD_DISPLAYON 0x04
#define LCD_DISPLAYOFF 0x00
#define LCD_CURSORON 0x02
#define LCD_CURSOROFF 0x00
#define LCD_BLINKON 0x01
#define LCD_BLINKOFF 0x00

// flags for display/cursor shift
#define LCD_DISPLAYMOVE 0x08
#define LCD_CURSORMOVE 0x00
#define LCD_MOVERIGHT 0x04
#define LCD_MOVELEFT 0x00

// flags for function set
#define LCD_8BITMODE 0x10
#define LCD_4BITMODE 0x00
#define LCD_2LINE 0x08
#define LCD_1LINE 0x00
#define LCD_5x10DOTS 0x04
#define LCD_5x8DOTS 0x00

// flags for backlight control
#define LCD_BACKLIGHT 0x08
#define LCD_NOBACKLIGHT 0x00

// flags for lower 4 bits of the i2c expander
#define EXPAND_RS 1 << 0
#define EXPAND_RW 1 << 1
#define EXPAND_CS 1 << 2
#define EXPAND_BL 1 << 3

// macros for setting and clearing bits
#define EXPAND_BIT(n)    1 << n
#define EXPAND_HIGHER(n) (n & 0xF0)
#define EXPAND_LOWER(n)  ((n & 0x0F) << 4)

// ///////////////////////////////////////////////////////
void dispNumCurrentPage(void){	
	uint8_t units = currentPage%10;
	
	char unitsAscii = 48 + units; // ascii offset
	
	send( (LCD_SETDDRAMADDR | 15), 0);
	send( unitsAscii , 1 );
}

// ///////////////////////////////////////////////////////
void dispValCurrControl(void){
	if( ccAssignments == 0 ) return; // nullptr, abort
	if( ctrlIsHooked  == 0 ) return; // nullptr, abort
	if( currentPExIdx < 0  ) return;
	if( currentPExIdx > NPEXCH  ) return;

	send( (LCD_SETDDRAMADDR | 10), 0);
	if( ctrlIsHooked[currControl] ){ send( '=' , 1 );	}
	else                           { send( '!' , 1 ); }
	
	uint8_t ccNum = ccAssignments[currentPExIdx];
	uint8_t ccVal = prevMidiValue[ccNum];
	
	uint8_t units = ccVal%10;
	uint8_t  tens = (ccVal/10)%10;
	uint8_t hunds = (ccVal/100)%10;
	
	char hundsAscii = 48 + hunds; // ascii offset
	char  tensAscii = 48 + tens;  // ascii offset
	char unitsAscii = 48 + units; // ascii offset
	
	send( (LCD_SETDDRAMADDR | 11), 0);
	send( hundsAscii , 1 );
	send( tensAscii  , 1 );
	send( unitsAscii , 1 );
}

void dispNumCurrControl(void){
     if( ccAssignments == 0 ){    // nullptr, use placeholder
	 send( LCD_SETDDRAMADDR, 0); // set cursor
	 send( '-', 1 );
	 send( '-', 1 );
	}
	else {                       // display assigned cc num

      if( currentPExIdx < 0 )      currentPExIdx = 0;
      if( currentPExIdx > NPEXCH ) currentPExIdx = NPEXCH;
      uint8_t ccNum = ccAssignments[currentPExIdx];
	  
	 uint8_t units = ccNum%10;
	 uint8_t  tens = (ccNum/10)%10;

	 char  tensAscii = 48 + tens;  // ascii offset
	 char unitsAscii = 48 + units; // ascii offset
	
	 send( (LCD_SETDDRAMADDR | 12), 0);
	 send( tensAscii , 1 );
	 send( unitsAscii , 1 );
	}
}

void dispLabelCurrControl(void) {
	char defaultLabel[16] = "[none]         ";
	char* string = &defaultLabel[0];
	
	// a control is selected? find the label
	if( currentPExIdx >= 0 && currentPExIdx <= NPEXCH ) {
		string = labels[currentPExIdx];
	
		// but if the control label is blank
		if ( string[0] == '\0' ) {
		  string = &defaultLabel[0];
		}
	}

	// display the name on the screen
	send( (LCD_SETDDRAMADDR | 0), 0); // cursor to left
	uint8_t pos = 0;
	while( *string != '\0' && pos < 16 ) {
		this->send( *string , 1 );
		pos++;
		string++;
	} 
	
	// erase any old remaining label text
	while( pos < 12 ) {
		this->send( ' ' , 1 );
		pos++;
	}
}

void writeString(char* string, uint8_t pos){
	
	send( (LCD_SETDDRAMADDR | pos), 0); // set cursor
	
	int32_t iteration = 16;
	while( iteration>0 ){
		if (*string == 0) break;
		send( *string, 1 ); // send data
		string++;
		iteration--;	
	}
}


void send(uint8_t value, uint8_t reg){
     // send reg=0 (RS=low=command)
     // send reg=1 (RS=high=display)
	write4bits( EXPAND_HIGHER(value) | reg | EXPAND_BL );
	write4bits( EXPAND_LOWER(value)  | reg | EXPAND_BL );
}


// transmits a byte to the expander
void expanderWrite(uint8_t value){
	// for performance reasons chibios i2cMasterTransmiTimeout()
	// requires data to be transmitted over i2c bus in SRAM
	static uint8_t txbuf[1] __attribute__ ((section (".sram2")));
	static systime_t timeout = MS2ST(50); // time in sys ticks for 50 msec

	txbuf[0] = value;
	i2cMasterTransmitTimeout(&I2CD1, 0x27, txbuf, 1, 0, 0, timeout);
}

void pulseEnable(uint8_t value){
	static systime_t usec1 = US2ST(1); // time in sys ticks for 1 usec
	static systime_t usec50 = US2ST(50); // time in sys ticks for 50 usec
	
	expanderWrite(value | EXPAND_CS); // enable pin is high
	chThdSleep(usec1);               // enable pulse must be >450ns

	expanderWrite(value & ~EXPAND_CS); // enable pin is low
	chThdSleep(usec50);               // commands need > 37us to settle	
}

// writes to the expander (all 8 bits actually) pulsing the CS(Enable) pin
void write4bits(uint8_t value){
	expanderWrite(value);
	pulseEnable(value);
}

// ///////////////////////

void loop(void){	

	// if new page selected
	if( previousPage != currentPage ){
	    previousPage  = currentPage;  // for next time

	    dispNumCurrentPage();         // repaint
	}

	// if a new parameter is selected
	if( previouPExIdx != currentPExIdx ){	
	    previouPExIdx  = currentPExIdx; // update for next time

	  //dispNumCurrControl();           // repaint
	  dispLabelCurrControl();
	}

	dispValCurrControl();               // may not repaint
}

// //////////////////////////////


void setup(void){

	chThdSleepMilliseconds(5); // min 4.1 msec

	// begin commands by turning RS, RW and CS(E) pins low
	expanderWrite(0);
	chThdSleepMilliseconds(450);

	//put the LCD into 4 bit mode
	// this is according to the hitachi HD44780 datasheet
	// figure 24, pg 46
	write4bits(0x03<<4); 
	chThdSleepMilliseconds(5); // min 4.1 msec
	write4bits(0x03<<4); 
	chThdSleepMilliseconds(5); // min 4.1 msec
	write4bits(0x03<<4);
	chThdSleepMilliseconds(1);

	write4bits(0x02<<4); // set 4-bit interface (D4 D5 D6 D7 only)

	// desired function set
	send(LCD_FUNCTIONSET | LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS, 0);

	// desired display mode
	send(LCD_DISPLAYCONTROL | LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF, 0);

	// clear off the display
	send(LCD_CLEARDISPLAY, 0);
	chThdSleepMilliseconds(5); // clear takes some time!

	send(LCD_ENTRYMODESET | LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT, 0);

	// reset cursor
	send(LCD_RETURNHOME, 0);
	chThdSleepMilliseconds(10);

	writeString( (char*)"MIDI Ch16       ", 0 );
	chThdSleepMilliseconds(500);
}]]></code.declaration>
         <code.init><![CDATA[// currentPExIdx is overriden by K-rate code
// we pull currentPExIdx value stored in companion 'panelMidi'
// the LCD thread handles updating and checking previouPExIDx
previouPExIdx = currentPExIdx = 0; 

// currentPage is overridden in K-rate code
// we pull the values from companion 'panelControl'
// the LCD thread handles updating and checking previousPage
previousPage = currentPage = 0;

// point to ccAssignments[] array in companion 'panelAssign'
ccAssignments = parent->instancepanelAssign_i.ccAssignments; 

// point to ctrlIsHooked[] array in companion 'panelControl'
ctrlIsHooked = parent->instancepanelControl_i.ctrlIsHooked;

// point to prevMidiValue[] array in companion 'panelMidi'
prevMidiValue = parent->instancepanelMidi_i.prevMidiValue;

// set up all labels to terminate at zeroth character
for(int label=0; label<NPEXCH; label++){
	//strncpy(labels[bank][label],"-",15);
	//memset(&labels[label][0], 0, 16);
	labels[label][0] = 0;
}

// setup the i2c pins
palSetPadMode(GPIOB, 8, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);// SCL
palSetPadMode(GPIOB, 9, PAL_MODE_ALTERNATE(4)|PAL_STM32_PUDR_PULLUP|PAL_STM32_OTYPE_OPENDRAIN);// SDA
static const I2CConfig i2cfg = {
    OPMODE_I2C,
    400000,
    FAST_DUTY_CYCLE_2,
};
i2cStart(&I2CD1, &i2cfg);

// set up the thread for the i2c LCD screen comms
Thd = chThdCreateStatic(
		waThreadX, 
		sizeof(waThreadX),
		NORMALPRIO, 
		ThreadX, 
		(void *)this);]]></code.init>
         <code.dispose><![CDATA[chThdTerminate(Thd);
chThdWait(Thd);

i2cStop(&I2CD1);
palSetPadMode(GPIOB, 8, PAL_MODE_INPUT_ANALOG);
palSetPadMode(GPIOB, 9, PAL_MODE_INPUT_ANALOG);
LogTextMessage("disposed");]]></code.dispose>
         <code.krate><![CDATA[// get currentPExIDx from companion 'panelMidi'
currentPExIdx = parent->instancepanelMidi_i.currentPExIdx;
currentPage   = parent->instancepanelControl_i.currPage;
currControl   = parent->instancepanelControl_i.currControl;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="56bfbb06-3642-4dcc-8f0b-52d27f24c98c" name="panelControl" x="84" y="686">
      <params>
         <bool32.tgl name="s" MidiCC="122" value="1"/>
      </params>
      <attribs/>
      <object id="patch/object" uuid="56bfbb06-3642-4dcc-8f0b-52d27f24c98c">
         <sDescription>&apos;s&apos; control is mapped to MIDI CC 122 (local control)</sDescription>
         <author>zenpho</author>
         <inlets/>
         <outlets/>
         <displays>
            <int32.label name="C" description="current &apos;last touched&apos; control"/>
            <int32.label name="P" description="current &apos;page&apos; of controls"/>
         </displays>
         <params>
            <bool32.tgl name="s"/>
         </params>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[/* we tx INTERNAL MIDI CC for potentiometers on adc inputs 0..11 here
   ...causing root midi handler to modify PExch[]->finalvalue nicely...
   ...and companion 'midiBridge' to spot changes and tx EXTERNAL MIDI CC
 */   
int32_t smoothedR2R;        // panel buttons connected to R-2R ladder
int32_t smoothAdcVal[13];   // panel potentiometers
int8_t  ctrlIsHooked[12];   // mechanism to inhibit MIDI tx on page change
int32_t currControl;        // recently 'touched' control 0..11
int32_t currPage;           // recently 'focused' page 0..7
int32_t prevPage;           // mechanism to inhibit MIDI tx on page change
int32_t* ccToPExLookup;     // pointer to [] in companion 'panelAssign'
int8_t* prevMidiValue;      // pointer to [] in companion 'panelMidi']]></code.declaration>
         <code.init><![CDATA[for(int i=0; i<12; i++ ){ ctrlIsHooked[i] = 0; }             // unhook
for(int i=0; i<13; i++ ){ smoothAdcVal[i] = adcvalues[i]; }  // identical
ccToPExLookup = parent->instancepanelAssign_i.ccToPExLookup; // [] pointer
prevMidiValue = parent->instancepanelMidi_i.prevMidiValue;   // [] pointer
currControl   = -1;                                          // unset
currPage      = 0;
prevPage      = 0;
smoothedR2R   = 0;]]></code.init>
         <code.krate><![CDATA[if(param_s){

   // eight buttons in an R-2R ladder DAC are connected to adc[12]
   // here we watch for rising edges to detect button presses
   int32_t R2R = adcvalues[12]<<15;
   smoothedR2R = ___SMMLA((smoothedR2R - R2R),(-1<<26)+(2000),smoothedR2R);
   if( (R2R - smoothedR2R) > 0x100000 ){ // rising?
   	R2R = smoothedR2R >> 21; // deliberate precision loss
     // you can expect 30, 37, 41, 44, 46, 48, 50, 51
   	if( R2R >= 29 && R2R < 35 ) currPage = 0; // 31
   	if( R2R >= 35 && R2R < 40 ) currPage = 1; // 37
   	if( R2R >= 40 && R2R < 43 ) currPage = 2; // 41
   	if( R2R >= 43 && R2R < 45 ) currPage = 3; // 44
   	if( R2R >= 45 && R2R < 47 ) currPage = 4; // 46

   	if( R2R > 50 && R2R < 52 ){ // currPage 7 // 51 // trigger state dump in companion panelMidi
   		MidiSend2((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_PROGRAM_CHANGE + MIDICHANNEL, 127);
   	}
   }

   // button press requested to change page?
   if( prevPage != currPage ){                
       prevPage = currPage;				 // update for next time
       currControl = -1;					 // flag
       for(int c=0; c<12; c++){ ctrlIsHooked[c] = 0; } // unhook
   }

   // control 'pages' offset the base ccNum for the twelve controls
   int ccOffset = 1;                          // range 1..119
   if( currPage == 0 ) ccOffset = 1;          // cc01..12
   if( currPage == 1 ) ccOffset = 16;         // cc16..27
   if( currPage == 2 ) ccOffset = 28;         // cc28..39
   if( currPage == 3 ) ccOffset = 40;         // cc40..51
   if( currPage == 4 ) ccOffset = 52;         // cc52..63
   if( currPage == 5 ) ccOffset = 64;         // cc64..75
   if( currPage == 6 ) ccOffset = 76;         // cc76..87
   if( currPage == 7 ) ccOffset = 88;         // cc88..99

   // controls that are 'touched' transmit internal MIDI cc
   for(int ctrl=0; ctrl<12; ctrl++){	      // range 0..11
	int midiCC    = ctrl + ccOffset;         // range 1..119
     if( midiCC < 1   ) midiCC = 1;
     if( midiCC > 119 ) midiCC = 119;
     int midiValue = __USAT(adcvalues[ctrl]>>5,7); // range 0..127

     // we only consider controls that are 'touched'
     int32_t adc = adcvalues[ctrl]<<15;       // 11bit val to upper bits
     int32_t *s = &smoothAdcVal[ctrl];        // 's' short for smoothed
     *s = ___SMMLA(*s-adc,(-1<<23),*s);       // apply lowpass with mulacc
     int32_t delta   = abs(*s - adc);         // compute difference
     int8_t touched = ( delta > (1<<21) );    // above threshold for movement?

     if( touched ){
	   currControl = ctrl;

	   // remember that companion 'panelLCD' is monitoring 'panelMidi'
	   // for changes to the currentPExIdx. we do this to know which 
	   // text label to draw for the currently 'touched' control... 
	   // we must therefore update 'panelMidi' currentPExIdx here so that
	   // 'panelMidi' can replace the value if a midi message arrives
	   // and if the PEx value changes via the java editor for example
	   parent->instancepanelMidi_i.currentPExIdx = ccToPExLookup[ midiCC ];

	   // remember also that prevMidiValue[] is stored in companion 'panelMidi'
	   // (as above) PEx changes from java editor, ext MIDI, or panel controls
	   // will update this prevMidiValue such that we are either 'hooked' or not 
	   if( midiValue == prevMidiValue[midiCC] ){ ctrlIsHooked[ctrl] = 1; }
	   //else { ctrlIsHooked[ctrl] = 0; }

        if( ctrlIsHooked[ctrl] ){
           MidiSend3((midi_device_t) MIDI_DEVICE_INTERNAL, 1, 
              MIDI_CONTROL_CHANGE + MIDICHANNEL, midiCC, midiValue);
        }//hooked?	
	
     }//currControl valid?
   }//for
}//if

// update displays
disp_C = currControl;
disp_P = currPage;]]></code.krate>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="707af941-b436-414f-bb29-24875b7db11d" name="panelMidi" x="154" y="686">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="707af941-b436-414f-bb29-24875b7db11d">
         <sDescription>here we tx MIDI CC when a PExch[]-&gt;finalvalue changes and we share values with various other companion &apos;panel...&apos; objects. the java editor code handles the rx of MIDI CC messages to set PEx values.</sDescription>
         <author>zenpho</author>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[/*
 * although we are called 'panelMidi' it is infact the java editor
 * code that handles the rx of MIDI CC messages to set PEx values
 * here we tx MIDI CC when a PExch[]->finalvalue changes and we
 * share values with various other companion 'panel...' objects
 * 
 * absolutely requires companion 'panelAssign' object
 * optional 'panelLCD' and optional 'panelControl'
 */
// pointers to data held in companion 'panelAssign' object
int8_t *ccAssignments = NULL; // detected MIDI CC numbers
int32_t *minimumPExVal = NULL; // detected minimum range
int32_t *maximumPExVal = NULL; // detected maximum range

int32_t *prevPExValues = NULL; // mechanism to spot PExch[] changes
int8_t  prevMidiValue[127]; // mechanism to spot MIDI CC changes

int32_t krateTimer; // mechanism to restrit MIDI transmission rate

int32_t MINBIPOLAR = -1<<27; // used for parameter range checking
int32_t MAXBIPOLAR =  1<<27; 
int32_t MINUNIPOLAR = 0;
int32_t MAXUNIPOLAR = 1<<27;

int32_t currentPExIdx; // companion 'panelLCD' uses this value

// various midi tx companions can use usb midi...
// send any midi msg to usb midi device to enable this
int32_t usb_midi_tx = false; // initially disabled]]></code.declaration>
         <code.init><![CDATA[krateTimer = 0;    // mechanism used to slow k-rate processing
currentPExIdx = 0; // companion 'panelLCD' uses this value
ccAssignments = parent->instancepanelAssign_i.ccAssignments;
prevPExValues = parent->instancepanelAssign_i.prevPExValues;
minimumPExVal = parent->instancepanelAssign_i.minimumPExVal;
maximumPExVal = parent->instancepanelAssign_i.maximumPExVal;

// invalidate prevPExValues triggering a complete state dump
for(int i=0; i<NPEXCH; i++){ prevPExValues[i] = -1<<31; }

// companions 'panelControl' and 'panelLCD' use these values
// K-rate code populates when PEx[] value changes are detected
for(int i=0; i<127; i++){ prevMidiValue[i] = 0; }

usb_midi_tx = true;]]></code.init>
         <code.krate><![CDATA[if( ++krateTimer < 30 ) return;           // process slower than krate
krateTimer = 0;                           // reset timer for next time

// no further processing when panelAssign is discovering parameters
if( parent->instancepanelAssign_i.isDiscovering ) return;

for(int i=0; i<NPEXCH; i++){              // for every param in PExch[]
	if( ccAssignments[i] < 0 ) continue; // if no cc assignment, advance
	
	ParameterExchange_t* PEx = &patchMeta.pPExch[i]; // point to param
	if( prevPExValues[i] != PEx->modvalue ){       // did value change?
		prevPExValues[i] = PEx->modvalue;         // update for next time

		currentPExIdx = i;					  // panelLCD uses this value
		//LogTextMessage("v %d", PEx->value);
		//LogTextMessage("mv %d", PEx->modvalue);
		//LogTextMessage("fv %d", PEx->finalvalue);

		int midiValue = __USAT(PEx->modvalue,7);  // range 0..127

		if( minimumPExVal[i] == MINBIPOLAR &&
		    maximumPExVal[i] == MAXBIPOLAR) { // do bipolar2unipolar conversion?
			int bip2uni = (PEx->modvalue>>1) + (1<<26); // half plus offset
			midiValue = __USAT(bip2uni>>20,7);     // range 0..127
		}
		else if( minimumPExVal[i] == MINUNIPOLAR &&
			    maximumPExVal[i] == MAXUNIPOLAR ) { // do toggle conversion?
			midiValue = __USAT(PEx->modvalue>>20,7);
		}

		int midiCC = ccAssignments[i];
		//LogTextMessage("TX cc%d %d", midiCC, midiValue);
		MidiSend3((midi_device_t) MIDI_DEVICE_DIN, 1, MIDI_CONTROL_CHANGE + MIDICHANNEL, midiCC&0x7F, midiValue&0x7F);

		if( usb_midi_tx )
		{
		  MidiSend3((midi_device_t) MIDI_DEVICE_USB_DEVICE, 1, MIDI_CONTROL_CHANGE + MIDICHANNEL, midiCC&0x7F, midiValue&0x7F);
		}

		// companions 'panelControl' and 'panelLCD' use this value
		prevMidiValue[midiCC] = midiValue;
	}//if
}//for]]></code.krate>
         <code.midihandler><![CDATA[// no further processing when panelAssign is discovering parameters
if( parent->instancepanelAssign_i.isDiscovering ) return;

// pgm0 on ch0 triggers statedump
if( (status == MIDI_PROGRAM_CHANGE + MIDICHANNEL) && data1 == 127 ){
    
    // invalidate prevPExValues triggering a complete state dump
    for(int i=0; i<NPEXCH; i++){ prevPExValues[i] = -1<<31; }
}

if( dev == MIDI_DEVICE_USB_DEVICE ) usb_midi_tx = true;]]></code.midihandler>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="0425637c-4a3b-4efd-b19f-7bbe8c9a7dbc" name="panelAssign" x="224" y="686">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="0425637c-4a3b-4efd-b19f-7bbe8c9a7dbc">
         <sDescription>run-time detection of patch parameters with MIDI CC assignments. Values detected here are shared among companion &apos;panel...&apos; objects</sDescription>
         <author>zenpho</author>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[/* at run-time we detect parameters in PExch[] that have been
   configured to respond to MIDI CC with the Java editor
   our findings may be shared with companion 'panel...' objects
*/

// companions 'panelControl' and 'panelMidi' use these lookup 
// tables know which PExIdx to use for a given midi CC number
// and to know which CC number is assigned to a given PExIdx
int8_t  ccAssignments[NPEXCH]; // detected MIDI CC for PExId
int32_t ccToPExLookup[127];    // detected PExId for MIDI CC

int32_t initialValues[NPEXCH]; // initial values from PExch[]
int32_t prevPExValues[NPEXCH]; // mechanism to spot PExch[] changes
int32_t minimumPExVal[NPEXCH]; // detected minimum values
int32_t maximumPExVal[NPEXCH]; // detected maximum values
const char* nameForPExVal[NPEXCH]; // detected names
bool    isDiscovering = false;

void ccDetect(ParameterExchange_t* PEx, int PExIdx){
	for(int cc=1; cc<119; cc++)
	{
      // try a low midi value
	 MidiSend3((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_CONTROL_CHANGE + MIDICHANNEL, cc, 127);
	 if( initialValues[PExIdx] != PEx->modvalue ){ ccAssignments[PExIdx] = cc; break; }

	 // try a high midi value
	 MidiSend3((midi_device_t) MIDI_DEVICE_INTERNAL, 1, MIDI_CONTROL_CHANGE + MIDICHANNEL, cc, 0);
	 if( initialValues[PExIdx] != PEx->modvalue ){ ccAssignments[PExIdx] = cc; break; }
	}
}

void discoverParameters(){
// display count of paramters in the patch
//LogTextMessage("patchMeta.numPEx: %d", patchMeta.numPEx);
//LogTextMessage("ObjectKvpRoot.apvp.length: %d", ObjectKvpRoot->apvp.length);

// ////////////////////////////////////////////////////////
// attempt to detect a MIDI CC assignment made by the Java editor
extern struct KeyValuePair *ObjectKvps[];
unsigned int rootPExIdx=0;  // index used for PExch[] array
bool shouldAbort = false;
do{
	ParameterExchange_t* PEx = &patchMeta.pPExch[rootPExIdx];
	KeyValuePair* kvp = 0;          // may remain nullptr

	// parent sub-patch relationship?
	if( PEx->pfunction == PropagateToSub ){ PEx = (ParameterExchange_t*) PEx->finalvalue; } 
	
	// setup
	nameForPExVal[rootPExIdx] = "mysteryPExVal";
	prevPExValues[rootPExIdx] = -1;
	minimumPExVal[rootPExIdx] = -1;
	maximumPExVal[rootPExIdx] = -1;
	ccAssignments[rootPExIdx] = -1;
	ccDetect(PEx, rootPExIdx);      // modifies ccAssignments[]	
	chThdSleepMilliseconds(10);
	restoreParameters();

	// try to locate this PEx ipValuePair KeyValuePair in ObjectKvps[]
	// this will only succed if KVP_RegisterObject() and SetKVP_IPVP()
	// has caused the PEx to be registered and assigned, but the java
	// editor (v1.0.12) does not register some params, unfortunately
	for(int k=0; k<ObjectKvpRoot->apvp.length; k++){ // all registered ObjectKvps[]
	   if( ObjectKvps[k]->kvptype == KVP_TYPE_IPVP ){// is ipvp?
    	     if( PEx == ObjectKvps[k]->ipvp.PEx ){       // match!
	 	  kvp = ObjectKvps[k];
    	     }//match?
	   }//ipvp?
	}//for

	// try to set isBipolarPExV[] from ipvp.minvalue .maxvalue
	if( kvp ){                                      // may be nullptr
	  minimumPExVal[rootPExIdx] = kvp->ipvp.minvalue;
	  maximumPExVal[rootPExIdx] = kvp->ipvp.maxvalue;
	  nameForPExVal[rootPExIdx] = kvp->keyname;
	}

	// if ccDetect() has assigned a valid ccAssignment[] entry 
	if( ccAssignments[rootPExIdx]>=1 && ccAssignments[rootPExIdx]<=119 ){
	  LogTextMessage("CC%d %x..%x i%x (%s) PEx[%d]",
	     ccAssignments[rootPExIdx],
	     minimumPExVal[rootPExIdx],
	     maximumPExVal[rootPExIdx],
	     initialValues[rootPExIdx],
          nameForPExVal[rootPExIdx],
	     rootPExIdx
	     );

	     // companions 'panelControl' and 'panelMidi' use these lookup 
	     // tables know which PExIdx to use for a given midi CC number
	     // and to know which CC number is assigned to a given PExIdx
	     ccToPExLookup[ ccAssignments[rootPExIdx] ] = rootPExIdx;
	}

	// copy param name into companion 'panelLCD' labels[]
	// we copy rather than point at nameForPExVal[] directly
	// because we can then make dynamic abbreviations easily
	strncpy(parent->instancepanelLCD_i.labels[rootPExIdx], 
	        nameForPExVal[rootPExIdx], 14);
	
	rootPExIdx++;
	if( rootPExIdx>=NPEXCH ) shouldAbort=true;
	
}while(!shouldAbort);
}// end discoverParameters()

// ////////////////////////////////////////////////////////
// restore values modified ccDetect() in discoverParameters()
void restoreParameters(){
  for(int pidx=0; pidx<NPEXCH; pidx++){
  	ParameterExchange_t* PEx = &patchMeta.pPExch[pidx];
  	PExParameterChange( PEx, initialValues[pidx], 0xFFFD );
  }//for
}// end restoreParameters)

void getinitParameters(){ 
  for(int pidx=0; pidx<NPEXCH; pidx++){
	ParameterExchange_t* PEx = &patchMeta.pPExch[pidx];
	initialValues[pidx] = PEx->modvalue;
  }
}// end getinitParameters()

msg_t ThreadX2(){
  isDiscovering = true;
  for(int c=0; c<127; c++){ ccToPExLookup[c] = -1; }
  getinitParameters();
  chThdSleepMilliseconds(1000);
  discoverParameters();
  isDiscovering = false;
  chThdExit((msg_t)0);
}
static msg_t ThreadX(void *arg) {
	((attr_parent *)arg)->ThreadX2();
}
WORKING_AREA(waThreadX, 1024);
Thread *Thd;]]></code.declaration>
         <code.init><![CDATA[Thd = chThdCreateStatic(waThreadX, 
      sizeof(waThreadX), NORMALPRIO, 
      ThreadX, (void *)this);]]></code.init>
         <code.dispose><![CDATA[chThdTerminate(Thd);
chThdWait(Thd);
LogTextMessage("disposed");]]></code.dispose>
      </object>
   </patchobj>
   <patchobj type="patch/object" uuid="70f70b50-8f58-4c07-8678-85f3ea27b76b" name="panelREADME" x="294" y="686">
      <params/>
      <attribs/>
      <object id="patch/object" uuid="70f70b50-8f58-4c07-8678-85f3ea27b76b">
         <sDescription>READ [Local Data] comments for more info - 2025 JUL 03 - ccsystem1t</sDescription>
         <author>zenpho</author>
         <inlets/>
         <outlets/>
         <displays/>
         <params/>
         <attribs/>
         <includes/>
         <code.declaration><![CDATA[/*
README - ccsystem1t - 2025 jul 03

simply add [panel...], then use the java editor right-click assign menu

supports rx via both DIN and USB midi
supports tx by DIN on startup (but any USB msg rxd further enables USB tx)
this allows usb-powerbank-only operation, and seamless DAW usb midi usage

several features are useful for working with a sequencer / DAW
use cc122 'local' to en/disable panel controls
use pgm127 'snapshot' to capture the system state

panel objects must be the LOWEST objects in the java patch editor
- these interact with each other using hacky-kludgy-API stuff
- so make sure they appear in order [LCD][Control][Midi][Assign]

[panelLCD] handles I2C communication with a 16x2 display
[panelControl] handles front panel pots/buttons (cc122 'local' to en/disable)
[panelAssign] detect at run-time params the Java editor assigned to a MIDI CC
[panelMidi] tx cc when the PExch[]->finalvalue changes
[panelMIDI] tx cc statedump when rx pgm127
*/]]></code.declaration>
      </object>
   </patchobj>
   <comment type="patch/comment" x="378" y="700" text="ccsystem1t"/>
   <comment type="patch/comment" x="378" y="714" text="tx any msg via USB to enable DIN+USB tx"/>
   <nets/>
   <settings>
      <subpatchmode>no</subpatchmode>
      <MidiChannel>1</MidiChannel>
      <NPresets>8</NPresets>
      <NPresetEntries>32</NPresetEntries>
      <NModulationSources>8</NModulationSources>
      <NModulationTargetsPerSource>8</NModulationTargetsPerSource>
   </settings>
   <notes><![CDATA[]]></notes>
   <windowPos>
      <x>347</x>
      <y>23</y>
      <width>933</width>
      <height>667</height>
   </windowPos>
</patch-1.0>